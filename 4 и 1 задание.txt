CREATE OR REPLACE TRIGGER smtp_insert --триггер, который вызывается после INSERT в таблицу new_tables
AFTER INSERT ON new_tables
FOR EACH ROW
DECLARE
     c utl_smtp.connection; -- переменная, представляющая smtp-соединение
     lvu_id lvus.lvu_id%TYPE; --переменная для хранения значения из таблицы lvus
     log_date logs.log_date%TYPE; --переменная для хранения значения из таблицы logs
     type_id types.type_id%TYPE; --переменная для хранения значения из таблицы types
     task_id tasks.task_id%TYPE; --переменная для хранения значения из таблицы tasks
     prog_id programs.program_id%TYPE; --переменная для хранения значения из таблицы programs
     smtpHost VARCHAR(65) := 'smtp.gmail.com';
	 smtpPort INTEGER:= 587;
	 emailHost VARCHAR(65) := 'demagogy2001@gmail.com';
	 emailPassword VARCHAR(65) := 'pavelko2709';
BEGIN  
    
    lvu_id := :new.lvu_id;
    log_date := :new.log_date;
    type_id := :new.type_id;
    task_id := :new.task_id;
    prog_id := :new.program_id;
    
    c := utl_smtp.open_connection(
            host => smtpHost
            ,port => smtpPort
            , wallet_path => 'file:C:\app\moroz\product\21c\admin\XE\wallet'
            , wallet_password => 'Walletnasta12'
            , secure_connection_before_smtp => false
       ); --когда так открывается коннектор, то ehlo. Это для обоих способов авторизации
    utl_smtp.ehlo(c, smtpHost);
    utl_smtp.starttls(c); --зашифрованный канал поверх обычного
    utl_smtp.ehlo(c, smtpHost);
    utl_smtp.auth(
      c => c,
      username => emailHost,
      password => emailPassword,
      schemes  => utl_smtp.all_schemes
				);
	
    IF task_id is null then 
        task_id:='';
    END IF;
    IF prog_id is null then 
        prog_id:='';
    END IF;
    IF type_id is null then 
        type_id:='';
    END IF;
    IF log_date is null then 
        log_date:='';
    END IF;
    IF lvu_id is null then 
        lvu_id:='';
    END IF;


    For i in (SELECT * FROM mails) loop        
        EXIT WHEN type_id = 0;
        
        utl_smtp.mail(c, emailHost);
		utl_smtp.rcpt(c, i.mail);
		utl_smtp.open_data(c); -- отправка команды data, после которой можно начать передачу письма
		utl_smtp.write_data(c, 'From: demagogy2001@gmail.com' || utl_tcp.crlf);
		utl_smtp.write_data(c, 'To:'|| i.mail || utl_tcp.crlf);
		utl_smtp.write_data(c, 'Subject: pismo'|| utl_tcp.crlf);
		utl_smtp.write_data(c, 'Content-Type: text/plain' || utl_tcp.crlf);
		utl_smtp.write_data(c, 'X-Mailer: SMTP' || utl_tcp.crlf);
		utl_smtp.write_data(c, utl_tcp.crlf);

	 
	
		utl_smtp.write_data(c, 'LVU=' || lvu_id || utl_tcp.CRLF ||
											   'LOG_DATE=' || TO_CHAR(log_date) || utl_tcp.CRLF ||
											   'TYPE_ID=' || type_id || utl_tcp.CRLF ||
											   'TASK_ID' || task_id || utl_tcp.CRLF ||
											   'PROGRAM_ID' || prog_id || utl_tcp.CRLF); --тело сообщения с нужными данными
		
		utl_smtp.close_data(c); --завершение сессии 
		
    END LOOP;
    utl_smtp.quit(c); --закрытие соединения 
EXCEPTION
    WHEN utl_smtp.transient_error OR utl_smtp.permanent_error THEN --transient_error - при получении кода 4хх(ошибка на стороне клиента); permanent_error - при получении кода 5хх(ошибка на стороне сервера)
        BEGIN
            utl_smtp.quit(c); -- при этих ошибках закрываем соединение
        EXCEPTION
            WHEN utl_smtp.transient_error OR utl_smtp.permanent_error THEN
                NULL; -- When the SMTP server is down or unavailable, we don't
                   -- have a connection to the server. The quit call will
                   -- raise an exception that we can ignore.
        END;
        raise_application_error(-20000,
           'Failed to send mail due to the following error: ' || sqlerrm); --вызываем исключение с сообщением(sqlerrm) об ошибки
END;


delete from new_tables where log_id = 8

INSERT INTO new_tables(log_id,log_date,session_id) --insert данных, после которых срабатывает триггер
VALUES(8,TO_DATE('2020/07/22', 'yyyy/mm/dd'),8);